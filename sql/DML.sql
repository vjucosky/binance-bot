USE STUDY

/*
	TRUNCATE TABLE BINANCE_DATASET_KLINE
*/

DECLARE @SYMBOL_ID AS int = 2                            -- LTC/BTC
DECLARE @DATASET_INTERVAL AS bigint = 1000 * 60 * 60 * 2 -- 2 horas
DECLARE @FIRST_OPEN_TIMESTAMP AS bigint = 1577836800000  -- 01/01/2020 00:00:00.000
DECLARE @LAST_CLOSE_TIMESTAMP AS bigint = 1580515199999  -- 31/01/2020 23:59:59.999

INSERT INTO BINANCE_DATASET_KLINE (
	DATASET_NUMBER,
	DATASET_ROW,
	TRADE_COUNT,
	OPEN_VALUE,
	HIGH_VALUE,
	LOW_VALUE,
	CLOSE_VALUE,
	BASE_ASSET_VOLUME,
	BASE_ASSET_TAKER_BUY_VOLUME,
	QUOTE_ASSET_VOLUME,
	QUOTE_ASSET_TAKER_BUY_VOLUME,
	OPEN_TIMESTAMP,
	CLOSE_TIMESTAMP
)
SELECT
	[CURRENT].OPEN_TIMESTAMP AS DATASET_NUMBER,
	ROW_NUMBER() OVER (PARTITION BY [CURRENT].OPEN_TIMESTAMP ORDER BY HISTORIC.OPEN_TIMESTAMP DESC) AS DATASET_ROW,
	HISTORIC.TRADE_COUNT,
	HISTORIC.OPEN_VALUE,
	HISTORIC.HIGH_VALUE,
	HISTORIC.LOW_VALUE,
	HISTORIC.CLOSE_VALUE,
	HISTORIC.BASE_ASSET_VOLUME,
	HISTORIC.BASE_ASSET_TAKER_BUY_VOLUME,
	HISTORIC.QUOTE_ASSET_VOLUME,
	HISTORIC.QUOTE_ASSET_TAKER_BUY_VOLUME,
	HISTORIC.OPEN_TIMESTAMP,
	HISTORIC.CLOSE_TIMESTAMP
FROM BINANCE_SYMBOL_KLINE AS [CURRENT]
INNER JOIN BINANCE_SYMBOL_KLINE AS HISTORIC
	ON
		[CURRENT].SYMBOL_ID = HISTORIC.SYMBOL_ID
		AND HISTORIC.OPEN_TIMESTAMP BETWEEN [CURRENT].CLOSE_TIMESTAMP - @DATASET_INTERVAL AND [CURRENT].CLOSE_TIMESTAMP
WHERE
	[CURRENT].SYMBOL_ID = @SYMBOL_ID
	AND HISTORIC.OPEN_TIMESTAMP >= @FIRST_OPEN_TIMESTAMP
	AND [CURRENT].CLOSE_TIMESTAMP <= @LAST_CLOSE_TIMESTAMP
ORDER BY
	DATASET_NUMBER,
	DATASET_ROW

SELECT
	COUNT(*) AS ROW_COUNT,
	COUNT(DISTINCT DATASET_NUMBER) AS DATASET_COUNT,
	MAX(DATASET_ROW) AS LARGEST_DATASET_ROW_COUNT,
	MIN(OPEN_TIMESTAMP) AS FIRST_OPEN_TIMESTAMP,
	MAX(CLOSE_TIMESTAMP) AS LAST_CLOSE_TIMESTAMP,
	dbo.FROM_UNIX_TIMESTAMP(MIN(OPEN_TIMESTAMP)) AS FIRST_OPENED_AT,
	dbo.FROM_UNIX_TIMESTAMP(MAX(CLOSE_TIMESTAMP)) AS LAST_CLOSED_AT
FROM BINANCE_DATASET_KLINE

DECLARE @PROFIT_MARGIN AS decimal(18, 8) = 1.03 -- 3% de margem de lucro
DECLARE @CURRENT_TICK AS int = 31;              -- A 31ª linha de cada dataset é considerada como o momento atual; as linhas 1-30 são consideradas como futuro

SELECT
	[SOURCE].ID,
	[SOURCE].DATASET_NUMBER,
	[SOURCE].DATASET_ROW,
	[SOURCE].TRADE_COUNT,
	[SOURCE].OPEN_VALUE,
	[SOURCE].HIGH_VALUE,
	[SOURCE].LOW_VALUE,
	[SOURCE].CLOSE_VALUE,
	[SOURCE].BASE_ASSET_VOLUME,
	[SOURCE].BASE_ASSET_TAKER_BUY_VOLUME,
	[SOURCE].QUOTE_ASSET_VOLUME,
	[SOURCE].QUOTE_ASSET_TAKER_BUY_VOLUME,
	[SOURCE].OPEN_TIMESTAMP,
	[SOURCE].CLOSE_TIMESTAMP,
	IIF([SOURCE].DATASET_ROW = @CURRENT_TICK, [TARGET].CLOSE_VALUE * @PROFIT_MARGIN, NULL) AS TARGET_SELL_VALUE,
	CASE
		WHEN [SOURCE].DATASET_ROW < @CURRENT_TICK AND (
			[SOURCE].OPEN_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
			OR [SOURCE].HIGH_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
			OR [SOURCE].LOW_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
			OR [SOURCE].CLOSE_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
		) THEN CAST(1 AS bit)
		WHEN [SOURCE].DATASET_ROW < @CURRENT_TICK THEN CAST(0 AS bit)
	END AS IS_PROFITABLE
FROM BINANCE_DATASET_KLINE AS [SOURCE]
LEFT JOIN BINANCE_DATASET_KLINE AS [TARGET]
	ON
		[SOURCE].DATASET_NUMBER = [TARGET].DATASET_NUMBER
		AND [TARGET].DATASET_ROW = @CURRENT_TICK
ORDER BY
	[SOURCE].DATASET_NUMBER,
	[SOURCE].DATASET_ROW
