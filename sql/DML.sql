USE STUDY

/*
	TRUNCATE TABLE BINANCE_DATASET_KLINE
*/

DECLARE @SYMBOL_ID AS int = 2                            -- LTC/BTC
DECLARE @DATASET_INTERVAL AS bigint = 1000 * 60 * 60 * 2 -- 2 horas
DECLARE @FIRST_OPEN_TIMESTAMP AS bigint = 1577836800000  -- 01/01/2020 00:00:00.000
DECLARE @LAST_CLOSE_TIMESTAMP AS bigint = 1580515199999  -- 31/01/2020 23:59:59.999

INSERT INTO BINANCE_DATASET_KLINE (
	DATASET_NUMBER,
	DATASET_ROW,
	TRADE_COUNT,
	OPEN_VALUE,
	HIGH_VALUE,
	LOW_VALUE,
	CLOSE_VALUE,
	BASE_ASSET_VOLUME,
	BASE_ASSET_TAKER_BUY_VOLUME,
	QUOTE_ASSET_VOLUME,
	QUOTE_ASSET_TAKER_BUY_VOLUME,
	OPEN_TIMESTAMP,
	CLOSE_TIMESTAMP
)
SELECT
	[CURRENT].OPEN_TIMESTAMP AS DATASET_NUMBER,
	ROW_NUMBER() OVER (PARTITION BY [CURRENT].OPEN_TIMESTAMP ORDER BY HISTORIC.OPEN_TIMESTAMP DESC) AS DATASET_ROW,
	HISTORIC.TRADE_COUNT,
	HISTORIC.OPEN_VALUE,
	HISTORIC.HIGH_VALUE,
	HISTORIC.LOW_VALUE,
	HISTORIC.CLOSE_VALUE,
	HISTORIC.BASE_ASSET_VOLUME,
	HISTORIC.BASE_ASSET_TAKER_BUY_VOLUME,
	HISTORIC.QUOTE_ASSET_VOLUME,
	HISTORIC.QUOTE_ASSET_TAKER_BUY_VOLUME,
	HISTORIC.OPEN_TIMESTAMP,
	HISTORIC.CLOSE_TIMESTAMP
FROM BINANCE_SYMBOL_KLINE AS [CURRENT]
INNER JOIN BINANCE_SYMBOL_KLINE AS HISTORIC
	ON
		[CURRENT].SYMBOL_ID = HISTORIC.SYMBOL_ID
		AND HISTORIC.OPEN_TIMESTAMP BETWEEN [CURRENT].CLOSE_TIMESTAMP - @DATASET_INTERVAL AND [CURRENT].CLOSE_TIMESTAMP
WHERE
	[CURRENT].SYMBOL_ID = @SYMBOL_ID
	AND HISTORIC.OPEN_TIMESTAMP >= @FIRST_OPEN_TIMESTAMP
	AND [CURRENT].CLOSE_TIMESTAMP <= @LAST_CLOSE_TIMESTAMP
ORDER BY
	DATASET_NUMBER,
	DATASET_ROW

/*
	Métricas para validação inicial dos datasets gerados.
*/

SELECT
	COUNT(*) AS ROW_COUNT,
	COUNT(DISTINCT DATASET_NUMBER) AS DATASET_COUNT,
	MAX(DATASET_ROW) AS LARGEST_DATASET_ROW_COUNT,
	MIN(OPEN_TIMESTAMP) AS FIRST_OPEN_TIMESTAMP,
	MAX(CLOSE_TIMESTAMP) AS LAST_CLOSE_TIMESTAMP,
	dbo.FROM_UNIX_TIMESTAMP(MIN(OPEN_TIMESTAMP)) AS FIRST_OPENED_AT,
	dbo.FROM_UNIX_TIMESTAMP(MAX(CLOSE_TIMESTAMP)) AS LAST_CLOSED_AT
FROM BINANCE_DATASET_KLINE

/*
	A query seguinte calcula o valor de venda desejado e adiciona uma flag caso a operação tenha condições para ser bem sucedida.

	Note que nesta etapa somente são gerados datasets inteiros (datasets que contenham menos linhas do que o correto – seja por falhas
	ou por estarem no início da partição – são omitidos).
*/

DECLARE @PROFIT_MARGIN AS decimal(18, 8) = 1.03 -- 3% de margem de lucro
DECLARE @CURRENT_TICK AS int = 31;              -- A 31ª linha de cada dataset é considerada como o momento atual; as linhas 1-30 são consideradas como futuro

SELECT
	BDK.ID,
	BDK.DATASET_NUMBER,
	BDK.DATASET_ROW,
	BDK.TRADE_COUNT,
	BDK.OPEN_VALUE,
	BDK.HIGH_VALUE,
	BDK.LOW_VALUE,
	BDK.CLOSE_VALUE,
	BDK.BASE_ASSET_VOLUME,
	BDK.BASE_ASSET_TAKER_BUY_VOLUME,
	BDK.QUOTE_ASSET_VOLUME,
	BDK.QUOTE_ASSET_TAKER_BUY_VOLUME,
	BDK.OPEN_TIMESTAMP,
	BDK.CLOSE_TIMESTAMP,
	[TARGET].TARGET_SELL_VALUE,
	[TARGET].IS_PROFITABLE
FROM BINANCE_DATASET_KLINE AS BDK
INNER JOIN (
	SELECT
		DATASET_NUMBER,
		MAX(TARGET_SELL_VALUE) AS TARGET_SELL_VALUE,
		CAST(MAX(IS_PROFITABLE) AS bit) AS IS_PROFITABLE
	FROM (
		SELECT
			[SOURCE].DATASET_NUMBER,
			[SOURCE].DATASET_ROW,
			IIF([SOURCE].DATASET_ROW = @CURRENT_TICK, [TARGET].CLOSE_VALUE * @PROFIT_MARGIN, NULL) AS TARGET_SELL_VALUE,
			CASE
				WHEN [SOURCE].DATASET_ROW < @CURRENT_TICK AND (
					[SOURCE].OPEN_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
					OR [SOURCE].HIGH_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
					OR [SOURCE].LOW_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
					OR [SOURCE].CLOSE_VALUE >= [TARGET].CLOSE_VALUE * @PROFIT_MARGIN
				) THEN 1
				WHEN [SOURCE].DATASET_ROW < @CURRENT_TICK THEN 0
			END AS IS_PROFITABLE
		FROM BINANCE_DATASET_KLINE AS [SOURCE]
		LEFT JOIN BINANCE_DATASET_KLINE AS [TARGET]
			ON
				[SOURCE].DATASET_NUMBER = [TARGET].DATASET_NUMBER
				AND [TARGET].DATASET_ROW = @CURRENT_TICK
	) AS S
	GROUP BY DATASET_NUMBER
	HAVING COUNT(*) = 120
) AS [TARGET]
	ON BDK.DATASET_NUMBER = [TARGET].DATASET_NUMBER
WHERE BDK.DATASET_ROW >= @CURRENT_TICK
ORDER BY
	BDK.DATASET_NUMBER,
	BDK.DATASET_ROW
